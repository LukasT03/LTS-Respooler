// ------------ LTS RESPOOLER CONTROL BOARD V3 CODE ---------------

#include <TMCStepper.h>
#include <NimBLEDevice.h>
#include <Preferences.h>
#include <math.h>
#include <string>
#include <WiFi.h>
#include <ArduinoJson.h>
#include <Arduino.h>
#include <driver/ledc.h>
#include "driver/gpio.h"

// ------------------------ Board Info ----------------------------
#define FIRMWARE_VERSION "1.0.0" // (final)
#define BOARD_NAME "CtrBoard V3"

// --------------------- Hardware Pin Defines ---------------------
#define TMC_UART_RX      18
#define TMC_UART_TX      17
#define STEP_PIN         14
#define DIR_PIN          21
#define EN_PIN           40
#define LED1_PIN         8
#define LED2_PIN         10
#define LED_CONN_PIN     47
#define FILAMENT_PIN     11
#define BUTTON_PIN       9

// ------------------------ Motor Parameters ----------------------
#define MICROSTEPPING      8
#define R_SENSE            0.11f

// -------------------- Timing and Limits --------------------------
#define START_INTERVAL_US         700
#define DEFAULT_INTERVAL_US       146
#define TORQUE_CHECK_INTERVAL_MS  50
#define BUTTON_DEBOUNCE_MS        50
#define ACCEL_UPDATE_INTERVAL     20
#define ACCEL_STEP                5
#define LED_CONN_PULSE_MAX        255
#define STATUS_NOTIFY_INTERVAL    400
#define LED_BLINK_INTERVAL        1000
#define TORQUE_SG_IGNORE          20
#define TORQUE_SG_LIMIT_LOW       0.72
#define TORQUE_SG_LIMIT_MED       0.85
#define TORQUE_SG_LIMIT_HIGH      0.97
#define TORQUE_BELOW_MS           700
#define MIN_RSSI_THRESHOLD        -90
#define FILAMENT_LOSS_CONFIRM_MS  100
#define STEP_DUTY_ON              512

#define STEP_LEDC_CHANNEL         LEDC_CHANNEL_3
#define STEP_LEDC_TIMER           LEDC_TIMER_2

#define LED_PWM_TIMER             LEDC_TIMER_0
#define LED1_CHANNEL              LEDC_CHANNEL_0
#define LED2_CHANNEL              LEDC_CHANNEL_1
#define LED_CONN_CHANNEL          LEDC_CHANNEL_2
#define LED_ACTIVE_LOW            0

// ------------------- BLE UUIDs -----------------------------------
#define SERVICE_UUID              "9E05D06D-68A7-4E1F-A503-AE26713AC101"
#define CHARACTERISTIC_UUID       "7CB2F1B4-7E3F-43D2-8C92-DF58C9A7B1A8"

// ------------------- Direct settings variables -------------------
int speedPercent = 100;                         // 50-100
int motorDirection = 0;                         // 0, 1
int ledBrightness = 50;                         // 0-100
bool useFilamentSensor = true;                  // true, false
int motorStrength = 100;                        // 80-120
int torqueLimit = 0;                            // 0-3
int jingleStyle = 0;                            // 0-3
unsigned long calibrationAt80Speed = 930000;    // ms
String wifiSSID = "";
String wifiPassword = "";

// --------------- High-Speed mode state -----------------
bool highSpeedMode = false;
int savedTorqueLimitHS = 0;
unsigned long baseTargetStepIntervalMicros = DEFAULT_INTERVAL_US;

// -------------------- Status variables & objects ------------------
HardwareSerial TMCSerial(1);
TMC2209Stepper driver(&TMCSerial, R_SENSE, 0);
NimBLECharacteristic* pCharacteristic = nullptr;
Preferences prefs;

StaticJsonDocument<512> lastStatusDoc;
bool errorFlag = false;
String errorMsg = "";

bool deviceConnected = false;
bool isMotorRunning = false;
bool shouldStartMotorNow = false;
bool filamentDetected = false;
bool pendingDirectionChange = false;
bool lastStableButtonState = HIGH;
bool ledState = false;
int newMotorDirection = 0;
int pwmValue = 0;
int triggerJingleNow = 0;
unsigned long delayStartUntil = 0;
unsigned long filamentLostSince = 0;
unsigned long stepIntervalMicros = START_INTERVAL_US;
unsigned long targetStepIntervalMicros = DEFAULT_INTERVAL_US;
unsigned long spoolingStartTime = 0;
unsigned long lastNotify = 0;
unsigned long lastLedToggle = 0;
unsigned long lastAccelUpdate = 0;
unsigned long lastConnLedTime = 0;
unsigned long lastDebounceTime = 0;
unsigned long lastIntervalMicros = 0;
bool feedbackActive = false;
int  feedbackTogglesRemaining = 0;
bool feedbackBlinkOn = false;
unsigned long feedbackNextToggle = 0;
unsigned long totalEstimatedTime = 0;
unsigned long pausedElapsed = 0;
float progress = 0.0;
bool kickstartActive = false;
unsigned long kickstartEnd = 0;

// ---- Status change detection fields ----
bool lastIsMotorRunning = false;
bool lastFilamentDetected = false;
float lastProgress = 0.0;
int lastSpeedPercent = 100;
int lastChipTemperature = 0;
int lastRemainingTime = 0;

// ------- WiFi scan task ------------
TaskHandle_t wifiScanTaskHandle = nullptr;
void wifiScanTask(void* parameter) {
    WiFi.disconnect(true);
    int n = WiFi.scanNetworks();
    StaticJsonDocument<256> ssidDoc;
    JsonArray arr = ssidDoc.createNestedArray("SSID_LIST");
    for (int i = 0; i < n; i++) {
        int rssi = WiFi.RSSI(i);
        if (rssi > MIN_RSSI_THRESHOLD) {
            String ssid = WiFi.SSID(i);
            if (ssid.length() > 0 && ssid.length() < 33) {
                arr.add(ssid);
            }
        }
    }
    if (deviceConnected && pCharacteristic) {
        String jsonOut;
        serializeJson(ssidDoc, jsonOut);
        pCharacteristic->setValue(jsonOut.c_str());
        pCharacteristic->notify();
    }
    WiFi.scanDelete();
    prefs.begin("respooler", true);
    String ssid = prefs.getString("ssid", "");
    String pwd = prefs.getString("pwd", "");
    prefs.end();
    if (ssid.length() > 0 && pwd.length() > 0) {
        WiFi.begin(ssid.c_str(), pwd.c_str());
    }
    wifiScanTaskHandle = nullptr;
    vTaskDelete(NULL);
}

// -------------- WLAN connect async status --------------
bool wifiConnectInProgress = false;
unsigned long wifiConnectStartTime = 0;

// ------------------ Helper and utility functions ---------------
int calculatePWM(int brightnessPercent) {
    float gamma = 2.2;
    float normalized = constrain(brightnessPercent, 0, 100) / 100.0;
    return round(pow(normalized, gamma) * 255);
}
int fanPWMFromSpeed(int percent) {
    return map(constrain(percent, 0, 100), 0, 100, 0, 255);
}
static inline void setLedDuty(uint8_t channel, uint8_t duty) {
    uint32_t d = LED_ACTIVE_LOW ? (255 - duty) : duty;
    ledc_set_duty(LEDC_LOW_SPEED_MODE, (ledc_channel_t)channel, d);
    ledc_update_duty(LEDC_LOW_SPEED_MODE, (ledc_channel_t)channel);
}
inline uint32_t stepFreqFromIntervalUs(unsigned long us) {
    if (us < 1) us = 1;
    return (uint32_t)(1000000UL / (2UL * us));
}
inline void stepperSetFreq(uint32_t freqHz) {
    if (freqHz < 1) freqHz = 1;
    ledc_set_freq(LEDC_LOW_SPEED_MODE, STEP_LEDC_TIMER, freqHz);
}
inline void stepperStart(uint32_t freqHz) {
    stepperSetFreq(freqHz);
    ledc_set_duty(LEDC_LOW_SPEED_MODE, STEP_LEDC_CHANNEL, STEP_DUTY_ON);
    ledc_update_duty(LEDC_LOW_SPEED_MODE, STEP_LEDC_CHANNEL);
}
inline void stepperStop() {
    ledc_set_duty(LEDC_LOW_SPEED_MODE, STEP_LEDC_CHANNEL, 0);
    ledc_update_duty(LEDC_LOW_SPEED_MODE, STEP_LEDC_CHANNEL);
}
int getSpeedPercentFromInterval(unsigned long intervalMicros) {
    float percent = 100.0 - ((intervalMicros - 110.0) * 50.0 / (200.0 - 110.0));
    return constrain(round(percent), 50, 100);
}

void applySpeedTarget() {
    if (highSpeedMode) {
        unsigned long adjusted = (unsigned long)round((double)baseTargetStepIntervalMicros / 1.4);
        if (adjusted < 50) adjusted = 50;
        targetStepIntervalMicros = adjusted;
    } else {
        targetStepIntervalMicros = baseTargetStepIntervalMicros;
    }
}
void loadSettings() {
    prefs.begin("respooler", true);
    baseTargetStepIntervalMicros = prefs.getUInt("speed", DEFAULT_INTERVAL_US);
    speedPercent = getSpeedPercentFromInterval(baseTargetStepIntervalMicros);

    motorDirection = prefs.getUInt("dir", 0);
    ledBrightness = prefs.getUInt("led", 50);
    useFilamentSensor = prefs.getBool("filamentSensor", true);
    motorStrength = prefs.getUInt("motorStrength", 100);

    bool hsPref = prefs.getBool("hs", false);
    unsigned int tlPref = prefs.getUInt("torqueLimit", 0);
    highSpeedMode = hsPref;
    if (highSpeedMode) {
        savedTorqueLimitHS = tlPref;
        torqueLimit = 0;
    } else {
        torqueLimit = tlPref;
        savedTorqueLimitHS = tlPref;
    }

    jingleStyle = prefs.getUInt("jingle", 0);
    calibrationAt80Speed = prefs.getULong("cal80", 930000);
    prefs.end();
    setMotorCurrent(motorStrength);
    pwmValue = calculatePWM(ledBrightness);
    digitalWrite(DIR_PIN, motorDirection);
    applySpeedTarget();
}
void setMotorCurrent(int percent) {
    int strengthCurrent = map(percent, 80, 120, 400, 1000);
    driver.rms_current(strengthCurrent + 150);
}

// ------------------- BLE status/error/settings -------------------
void sendStatus(bool forceSend = false) {
    if (!deviceConnected || !pCharacteristic) return;

    float progVal = progress;
    int remVal = 0;
    if (isMotorRunning && totalEstimatedTime > 0) {
        unsigned long elapsed = millis() - spoolingStartTime;
        progVal = min(100.0f, 100.0f * elapsed / totalEstimatedTime);
        remVal = (totalEstimatedTime - elapsed) / 1000;
    }
    int chipTemp = (int)temperatureRead();

    StaticJsonDocument<512> doc;
    JsonObject stat = doc.createNestedObject("STAT");
    stat["RUN"] = isMotorRunning;
    stat["HAS_FIL"] = filamentDetected;
    stat["USE_FIL"] = useFilamentSensor;
    stat["PROG"] = progVal;
    stat["REM"] = remVal;
    stat["ERR"] = errorFlag;
    stat["ERR_MSG"] = errorFlag ? errorMsg.c_str() : nullptr;
    stat["TEMP"] = chipTemp;
    stat["WIFI_SSID"] = wifiSSID.length() > 0 ? wifiSSID.c_str() : nullptr;
    stat["WIFI_OK"] = WiFi.status() == WL_CONNECTED;
    stat["FW"] = FIRMWARE_VERSION;
    stat["SPD"] = speedPercent;
    stat["JIN"] = jingleStyle;
    stat["LED"] = ledBrightness;
    stat["DIR"] = motorDirection;
    stat["POW"] = motorStrength;
    stat["TRQ"] = highSpeedMode ? 0 : torqueLimit;
    stat["DUR"] = calibrationAt80Speed / 1000;
    stat["HS"]  = highSpeedMode;

    lastIsMotorRunning = isMotorRunning;
    lastFilamentDetected = filamentDetected;
    lastProgress = progVal;
    lastChipTemperature = chipTemp;
    lastRemainingTime = remVal;
    lastSpeedPercent = speedPercent;

    String jsonOut;
    serializeJson(doc, jsonOut);
    pCharacteristic->setValue(jsonOut.c_str());
    pCharacteristic->notify();
}

// ------------------- Stepper jingle/tones --------------------------
void playTone(unsigned int freqHz, unsigned long durationMs) {
    uint16_t prevCurrent = driver.rms_current();
    driver.rms_current(1400);
    unsigned long halfPeriod = 1000000UL / (2 * freqHz);
    unsigned long totalCycles = (durationMs * 1000UL) / (2 * halfPeriod);
    bool dirState = false;
    for (unsigned long i = 0; i < totalCycles; i++) {
        dirState = !dirState;
        digitalWrite(DIR_PIN, dirState);
        digitalWrite(STEP_PIN, HIGH);
        delayMicroseconds(40);
        digitalWrite(STEP_PIN, LOW);
        delayMicroseconds(halfPeriod * 2 - 40);
    }
    driver.rms_current(prevCurrent);
}
void playStepperJingle() {
    if (jingleStyle == 0) return;
    delay(500);
    stepperStop();
    ledc_stop(LEDC_LOW_SPEED_MODE, STEP_LEDC_CHANNEL, 0);
    gpio_reset_pin((gpio_num_t)STEP_PIN);
    gpio_set_direction((gpio_num_t)STEP_PIN, GPIO_MODE_OUTPUT);
    digitalWrite(EN_PIN, LOW);
    digitalWrite(STEP_PIN, LOW);
    switch (jingleStyle) {
        case 1: // simple
            playTone(1000, 140); delay(20);
            playTone(800, 140); delay(20);
            playTone(1200, 400);
            break;
        case 2: // glissando
            playTone(523, 220); delay(20);
            playTone(587, 70); delay(20);
            playTone(659, 70); delay(20);
            playTone(698, 70); delay(20);
            playTone(784, 70); delay(20);
            playTone(880, 70); delay(20);
            playTone(988, 100); delay(20);
            playTone(1047, 400);
            break;
        case 3: // Star Wars
            playTone(440, 400); delay(40);
            playTone(440, 400); delay(40);
            playTone(440, 400); delay(40);
            playTone(349, 250); delay(40);
            playTone(523, 150); delay(40);
            playTone(440, 400); delay(40);
            playTone(349, 250); delay(40);
            playTone(523, 150); delay(40);
            playTone(440, 500);
            break;
    }
    digitalWrite(EN_PIN, HIGH);
    {
        ledc_channel_config_t step_ledc_chan = {
            .gpio_num       = STEP_PIN,
            .speed_mode     = LEDC_LOW_SPEED_MODE,
            .channel        = STEP_LEDC_CHANNEL,
            .intr_type      = LEDC_INTR_DISABLE,
            .timer_sel      = STEP_LEDC_TIMER,
            .duty           = 0,
            .hpoint         = 0
        };
        ledc_channel_config(&step_ledc_chan);
    }
    stepperStop();
}

// ------------------- BLE command handling -------------------------
void handleCommand(const std::string& cmd) {
    StaticJsonDocument<512> doc;
    DeserializationError error = deserializeJson(doc, cmd.c_str());
    if (error) return;

    if (doc.containsKey("CMD")) {
        String command = doc["CMD"].as<String>();
        if (command == "START") {
            if (!isMotorRunning) {
                shouldStartMotorNow = true;
                delayStartUntil = millis();
            }
        }
        else if (command == "STOP") {
            isMotorRunning = false;
            progress = 0.0;
            totalEstimatedTime = 0;
            spoolingStartTime = 0;
            stepperStop();
            digitalWrite(EN_PIN, HIGH);
            digitalWrite(STEP_PIN, LOW);
            driver.en_spreadCycle(false);
            kickstartActive = false;
            sendStatus(true);
        }
        else if (command == "WIFI_SCAN") {
          if (wifiScanTaskHandle == nullptr) {
              xTaskCreate(wifiScanTask, "WiFiScan", 4096, NULL, 1, &wifiScanTaskHandle);
          }
        }
        else if (command == "WIFI_CONNECT") {
            if (wifiSSID.length() > 0 && wifiPassword.length() > 0) {
                WiFi.disconnect(true);
                WiFi.begin(wifiSSID.c_str(), wifiPassword.c_str());
                wifiConnectInProgress = true;
                wifiConnectStartTime = millis();
            }
        }
    }

    if (doc.containsKey("SET")) {
        JsonObject set = doc["SET"].as<JsonObject>();
        bool changed = false;
        if (set.containsKey("DIR")) {
            int dir = set["DIR"];
            if (dir != motorDirection) {
                if (isMotorRunning) {
                    pendingDirectionChange = true;
                    newMotorDirection = dir;
                    isMotorRunning = false;
                    stepperStop();
                    digitalWrite(EN_PIN, HIGH);
                    digitalWrite(STEP_PIN, LOW);
                } else {
                    motorDirection = dir;
                    digitalWrite(DIR_PIN, motorDirection);
                    prefs.begin("respooler", false);
                    prefs.putUInt("dir", motorDirection);
                    prefs.end();
                }
                changed = true;
            }
        }
        if (set.containsKey("LED")) {
            ledBrightness = constrain((int)set["LED"], 0, 100);
            pwmValue = calculatePWM(ledBrightness);
            prefs.begin("respooler", false);
            prefs.putUInt("led", ledBrightness);
            prefs.end();
            changed = true;
        }
        if (set.containsKey("USE_FIL")) {
            useFilamentSensor = (int)set["USE_FIL"] != 0;
            prefs.begin("respooler", false);
            prefs.putBool("filamentSensor", useFilamentSensor);
            prefs.end();
            changed = true;
        }
        if (set.containsKey("POW")) {
            motorStrength = constrain((int)set["POW"], 80, 120);
            setMotorCurrent(motorStrength);
            prefs.begin("respooler", false);
            prefs.putUInt("motorStrength", motorStrength);
            prefs.end();
            changed = true;
        }
        if (set.containsKey("TRQ")) {
            int newTrq = constrain((int)set["TRQ"], 0, 3);
            if (highSpeedMode) {
                savedTorqueLimitHS = newTrq;
                prefs.begin("respooler", false);
                prefs.putUInt("torqueLimit", (unsigned int)savedTorqueLimitHS);
                prefs.end();
                torqueLimit = 0;
            } else {
                torqueLimit = newTrq;
                prefs.begin("respooler", false);
                prefs.putUInt("torqueLimit", (unsigned int)torqueLimit);
                prefs.end();
            }
            changed = true;
        }
        if (set.containsKey("JIN")) {
            int newJingleStyle = constrain((int)set["JIN"], 0, 3);
            if (newJingleStyle != jingleStyle) {
                jingleStyle = newJingleStyle;
                prefs.begin("respooler", false);
                prefs.putUInt("jingle", jingleStyle);
                prefs.end();
                if (!isMotorRunning) triggerJingleNow = jingleStyle;
                changed = true;
            }
        }
        if (set.containsKey("DUR")) {
            unsigned long dur = (unsigned long)set["DUR"];
            if (dur >= 10 && dur <= 20000) {
                calibrationAt80Speed = dur * 1000UL;
                prefs.begin("respooler", false);
                prefs.putULong("cal80", calibrationAt80Speed);
                prefs.end();
                changed = true;
            }
        }
        if (set.containsKey("SPD")) {
            int speed = constrain((int)set["SPD"], 50, 100);
            baseTargetStepIntervalMicros = map(speed, 50, 100, 200, 110);
            speedPercent = speed;
            prefs.begin("respooler", false);
            prefs.putUInt("speed", baseTargetStepIntervalMicros);
            prefs.end();
            applySpeedTarget();
            changed = true;
        }
        if (set.containsKey("HS")) {
            bool newHS = (int)set["HS"] != 0;
            if (newHS != highSpeedMode) {
                if (newHS) {
                    highSpeedMode = true;
                    savedTorqueLimitHS = torqueLimit;
                    torqueLimit = 0;
                    prefs.begin("respooler", false);
                    prefs.putBool("hs", true);
                    prefs.putUInt("torqueLimit", (unsigned int)savedTorqueLimitHS);
                    prefs.end();
                    applySpeedTarget();
                } else {
                    highSpeedMode = false;
                    torqueLimit = savedTorqueLimitHS;
                    prefs.begin("respooler", false);
                    prefs.putBool("hs", false);
                    prefs.putUInt("torqueLimit", (unsigned int)torqueLimit);
                    prefs.end();
                    applySpeedTarget();
                }
                changed = true;
            }
        }
        if (set.containsKey("WIFI_SSID")) {
            wifiSSID = set["WIFI_SSID"].as<String>();
            changed = true;
        }
        if (set.containsKey("WIFI_PASS")) {
            wifiPassword = set["WIFI_PASS"].as<String>();
            changed = true;
        }
        if (changed) {
            prefs.begin("respooler", false);
            prefs.putString("ssid", wifiSSID);
            prefs.putString("pwd", wifiPassword);
            prefs.end();
            sendStatus(true);
        }
    }
}

// ------------------- BLE callback classes ------------------------
class MyServerCallbacks : public NimBLEServerCallbacks {
    void onConnect(NimBLEServer* pServer, NimBLEConnInfo&) override {
        deviceConnected = true;
        if (pServer->getConnectedCount() < 2) {
            NimBLEDevice::startAdvertising();
        }
        xTaskCreate([](void*) {
            delay(1100);
            sendStatus(true);
            vTaskDelete(NULL);
        }, "delayedSend", 2048, NULL, 1, NULL);
    }
    void onDisconnect(NimBLEServer* pServer, NimBLEConnInfo&, int) override {
        deviceConnected = pServer->getConnectedCount() > 0;
        if (pServer->getConnectedCount() < 2) {
            NimBLEDevice::startAdvertising();
        }
    }
};
class MyCharacteristicCallbacks : public NimBLECharacteristicCallbacks {
    void onWrite(NimBLECharacteristic* pChar, NimBLEConnInfo&) override {
        std::string rx = pChar->getValue();
        if (!rx.empty()) handleCommand(rx);
    }
};

// ------------------------ Setup ----------------------------------
void setup() {
    pinMode(FILAMENT_PIN, INPUT_PULLUP);
    pinMode(BUTTON_PIN, INPUT_PULLUP);
    pinMode(STEP_PIN, OUTPUT);
    pinMode(DIR_PIN, OUTPUT);
    pinMode(EN_PIN, OUTPUT); digitalWrite(EN_PIN, HIGH);
    pinMode(LED1_PIN, OUTPUT);
    pinMode(LED2_PIN, OUTPUT);
    pinMode(LED_CONN_PIN, OUTPUT);

    ledc_timer_config_t led_timer = {
        .speed_mode      = LEDC_LOW_SPEED_MODE,
        .duty_resolution = LEDC_TIMER_8_BIT,
        .timer_num       = LED_PWM_TIMER,
        .freq_hz         = 1000,
        .clk_cfg         = LEDC_USE_APB_CLK
    };
    ledc_timer_config(&led_timer);

    ledc_channel_config_t led1_conf = {
        .gpio_num       = LED1_PIN,
        .speed_mode     = LEDC_LOW_SPEED_MODE,
        .channel        = LED1_CHANNEL,
        .intr_type      = LEDC_INTR_DISABLE,
        .timer_sel      = LED_PWM_TIMER,
        .duty           = 0,
        .hpoint         = 0
    };
    ledc_channel_config(&led1_conf);

    ledc_channel_config_t led2_conf = {
        .gpio_num       = LED2_PIN,
        .speed_mode     = LEDC_LOW_SPEED_MODE,
        .channel        = LED2_CHANNEL,
        .intr_type      = LEDC_INTR_DISABLE,
        .timer_sel      = LED_PWM_TIMER,
        .duty           = 0,
        .hpoint         = 0
    };
    ledc_channel_config(&led2_conf);

    ledc_channel_config_t ledc_conf = {
        .gpio_num       = LED_CONN_PIN,
        .speed_mode     = LEDC_LOW_SPEED_MODE,
        .channel        = LED_CONN_CHANNEL,
        .intr_type      = LEDC_INTR_DISABLE,
        .timer_sel      = LED_PWM_TIMER,
        .duty           = 0,
        .hpoint         = 0
    };
    ledc_channel_config(&ledc_conf);

    ledc_timer_config_t step_ledc_timer = {
        .speed_mode      = LEDC_LOW_SPEED_MODE,
        .duty_resolution = LEDC_TIMER_10_BIT,
        .timer_num       = STEP_LEDC_TIMER,
        .freq_hz         = 1000,
        .clk_cfg         = LEDC_USE_APB_CLK
    };
    ledc_timer_config(&step_ledc_timer);

    ledc_channel_config_t step_ledc_chan = {
        .gpio_num       = STEP_PIN,
        .speed_mode     = LEDC_LOW_SPEED_MODE,
        .channel        = STEP_LEDC_CHANNEL,
        .intr_type      = LEDC_INTR_DISABLE,
        .timer_sel      = STEP_LEDC_TIMER,
        .duty           = 0,
        .hpoint         = 0
    };
    ledc_channel_config(&step_ledc_chan);

    Serial.begin(115200);
    TMCSerial.begin(115200, SERIAL_8N1, TMC_UART_RX, TMC_UART_TX);

    driver.begin();
    driver.toff(3);
    driver.microsteps(MICROSTEPPING);
    driver.en_spreadCycle(false);
    driver.pwm_autoscale(true);
    driver.pwm_autograd(true);
    driver.TPWMTHRS(80);
    driver.SGTHRS(40); 
    driver.semin(0);
    driver.TCOOLTHRS(0xFFFFF);
    uint16_t cool = driver.COOLCONF();
    driver.COOLCONF(cool | (1 << 13));

    prefs.begin("respooler", true);
    wifiSSID = prefs.getString("ssid", "");
    wifiPassword = prefs.getString("pwd", "");
    prefs.end();
    WiFi.mode(WIFI_STA);
    WiFi.disconnect(true);

    if (wifiSSID.length() > 0 && wifiPassword.length() > 0) {
        WiFi.begin(wifiSSID.c_str(), wifiPassword.c_str());
    }

    loadSettings();
    setMotorCurrent(motorStrength);
    pwmValue = calculatePWM(ledBrightness);

    NimBLEDevice::init(BOARD_NAME);
    NimBLEDevice::setMTU(512);
    NimBLEServer* pServer = NimBLEDevice::createServer();
    pServer->setCallbacks(new MyServerCallbacks());

    NimBLEService* pService = pServer->createService(SERVICE_UUID);
    pCharacteristic = pService->createCharacteristic(
        CHARACTERISTIC_UUID, NIMBLE_PROPERTY::WRITE | NIMBLE_PROPERTY::NOTIFY
    );
    pCharacteristic->setCallbacks(new MyCharacteristicCallbacks());
    pService->start();

    NimBLEAdvertising* pAdvertising = NimBLEDevice::getAdvertising();
    NimBLEAdvertisementData advData;
    advData.setName(BOARD_NAME);
    advData.addServiceUUID(SERVICE_UUID);
    pAdvertising->setAdvertisementData(advData);
    pAdvertising->start();

    int startupPWM = calculatePWM(50);
    setLedDuty(LED1_CHANNEL, startupPWM);
    setLedDuty(LED2_CHANNEL, startupPWM);
    setLedDuty(LED_CONN_CHANNEL, 0);
    delay(500);
    setLedDuty(LED1_CHANNEL, 0);
    setLedDuty(LED2_CHANNEL, 0);
    setLedDuty(LED_CONN_CHANNEL, 0);
}

// ------------------- Main loop -----------------------------------
void loop() {
    unsigned long now = millis();

    // ------------------ WLAN connect async check -----------------
    if (wifiConnectInProgress) {
        if (WiFi.status() == WL_CONNECTED) {
            wifiConnectInProgress = false;
            if (deviceConnected && pCharacteristic) {
                StaticJsonDocument<64> doc;
                doc["WIFI_CONN_RESULT"] = true;
                String jsonOut;
                serializeJson(doc, jsonOut);
                pCharacteristic->setValue(jsonOut.c_str());
                pCharacteristic->notify();
            }
            prefs.begin("respooler", false);
            prefs.putString("ssid", wifiSSID);
            prefs.putString("pwd", wifiPassword);
            prefs.end();
        } else if (millis() - wifiConnectStartTime > 10000) {
            wifiConnectInProgress = false;
            if (deviceConnected && pCharacteristic) {
                StaticJsonDocument<64> doc;
                doc["WIFI_CONN_RESULT"] = false;
                String jsonOut;
                serializeJson(doc, jsonOut);
                pCharacteristic->setValue(jsonOut.c_str());
                pCharacteristic->notify();
            }
        }
    }

    // ------------------ Filament sensor -----------------
    bool rawFilamentPresent = digitalRead(FILAMENT_PIN) == LOW;
    if (rawFilamentPresent) {
        filamentLostSince = 0;
        filamentDetected = true;
    } else {
        if (filamentLostSince == 0) {
            filamentLostSince = now;
        }
        if (filamentDetected && (now - filamentLostSince >= FILAMENT_LOSS_CONFIRM_MS)) {
            filamentDetected = false;
        }
    }

    // ------------------ Motor/LED state -----------------
    if (!feedbackActive) {
        if (isMotorRunning) {
            if (now - lastLedToggle > LED_BLINK_INTERVAL) {
                lastLedToggle = now;
                ledState = !ledState;
            }
            setLedDuty(LED1_CHANNEL, ledState ? pwmValue : 0);
        } else {
            setLedDuty(LED1_CHANNEL, 0);
        }
    }

    if (!feedbackActive) {
        uint8_t v;
        if (useFilamentSensor) {
            v = filamentDetected ? pwmValue : 0;
        } else {
            v = isMotorRunning ? (ledState ? pwmValue : 0) : 0;
        }
        setLedDuty(LED2_CHANNEL, v);
    }

    // ----- Non-blocking button feedback blink driver -----
    if (feedbackActive) {
        if (now >= feedbackNextToggle) {
            feedbackBlinkOn = !feedbackBlinkOn;
            setLedDuty(LED1_CHANNEL, feedbackBlinkOn ? pwmValue : 0);
            setLedDuty(LED2_CHANNEL, feedbackBlinkOn ? pwmValue : 0);
            feedbackNextToggle = now + 100;
            if (--feedbackTogglesRemaining <= 0) {
                feedbackActive = false;
                setLedDuty(LED1_CHANNEL, 0);
                setLedDuty(LED2_CHANNEL, 0);
            }
        }
    }

    // ----------- StallGuard/torque auto-stop -----------
    static unsigned long lastTorqueCheck = 0;
    static unsigned long torqueBelowStartTime = 0;
    if (torqueLimit > 0 && isMotorRunning && stepIntervalMicros == targetStepIntervalMicros) {
        if (now - lastTorqueCheck >= TORQUE_CHECK_INTERVAL_MS) {
            lastTorqueCheck = now;
            uint16_t sg = driver.SG_RESULT();
            if (sg > TORQUE_SG_IGNORE) {

                float strengthScale = 1.0;
                int baseLimit = 350 * strengthScale;
                int limit = 999;
                if (torqueLimit == 1) limit = baseLimit * TORQUE_SG_LIMIT_LOW;
                else if (torqueLimit == 2) limit = baseLimit * TORQUE_SG_LIMIT_MED;
                else if (torqueLimit == 3) limit = baseLimit * TORQUE_SG_LIMIT_HIGH;

                int currSpeedPercent = getSpeedPercentFromInterval(stepIntervalMicros);
                if (currSpeedPercent > 94) {
                    limit = limit * 0.95;
                } else if (currSpeedPercent > 85) {
                    limit = limit * 0.97;
                } else if (currSpeedPercent < 65) {
                    limit = limit * 0.98;
                }

                if (sg < limit) {
                    if (torqueBelowStartTime == 0) torqueBelowStartTime = now;
                    else if (now - torqueBelowStartTime >= TORQUE_BELOW_MS) {
                        isMotorRunning = false;
                        errorFlag = true;
                        errorMsg = "Auto-Stopp ausgelöst";
                        sendStatus(true);
                        digitalWrite(STEP_PIN, LOW);
                        delay(100);
                        digitalWrite(EN_PIN, HIGH);
                        unsigned long elapsed = millis() - spoolingStartTime;
                        spoolingStartTime = 0;
                        pausedElapsed = elapsed;
                        torqueBelowStartTime = 0;
                        stepperStop();
                        driver.en_spreadCycle(false);
                        kickstartActive = false;
                        digitalWrite(EN_PIN, LOW); digitalWrite(STEP_PIN, LOW);
                        delay(500);
                        for (int i = 0; i < 3; i++) { playTone(850, 250); delay(100); }
                        digitalWrite(EN_PIN, HIGH);
                    }
                } else { torqueBelowStartTime = 0; }
            }
        }
    } else { torqueBelowStartTime = 0; }

    // ----- Respooler done -> Motor off + jingle -----
    if (isMotorRunning && useFilamentSensor && !filamentDetected && filamentLostSince > 0 && now - filamentLostSince > FILAMENT_LOSS_CONFIRM_MS) {
        isMotorRunning = false;
        digitalWrite(STEP_PIN, LOW);
        stepperStop();
        delay(40);
        digitalWrite(EN_PIN, HIGH);

        progress = 0.0;
        totalEstimatedTime = 0;
        spoolingStartTime = 0;
        if (deviceConnected && pCharacteristic) {
            StaticJsonDocument<64> doc;
            doc["DONE"] = true;
            String jsonOut;
            serializeJson(doc, jsonOut);
            pCharacteristic->setValue(jsonOut.c_str());
            pCharacteristic->notify();
        }
        sendStatus(true);
        delay(400);
        playStepperJingle();
    }

    // ------- Direction change after stop -----------
    if (pendingDirectionChange && !isMotorRunning) {
        kickstartActive = false;
        motorDirection = newMotorDirection;
        prefs.begin("respooler", false);
        prefs.putUInt("dir", motorDirection);
        prefs.end();
        digitalWrite(DIR_PIN, motorDirection);
        delayStartUntil = now + 1000;
        shouldStartMotorNow = true;
        pendingDirectionChange = false;
    }

    // ------------ Motor start logic ----------------
    if (shouldStartMotorNow && now >= delayStartUntil) {
        if (isMotorRunning) { shouldStartMotorNow = false; }
        else if (!useFilamentSensor || filamentDetected) {
            errorFlag = false;
            errorMsg = "";
            stepperStop();
            digitalWrite(DIR_PIN, motorDirection);
            digitalWrite(EN_PIN, LOW);
            digitalWrite(STEP_PIN, LOW);
            delay(15);
            stepIntervalMicros = START_INTERVAL_US;
            lastAccelUpdate = now;
            isMotorRunning = true;
            driver.en_spreadCycle(true);
            kickstartActive = true;
            kickstartEnd = now + 150;
            stepperStart(stepFreqFromIntervalUs(stepIntervalMicros));
            int currSpeedPercent = round((float)speedPercent * ((float)baseTargetStepIntervalMicros / (float)targetStepIntervalMicros));
            currSpeedPercent = constrain(currSpeedPercent, 50, 140);
            totalEstimatedTime = calibrationAt80Speed * (80.0 / currSpeedPercent);
            if (pausedElapsed > 0) {
                spoolingStartTime = millis() - pausedElapsed; pausedElapsed = 0;
            } else {
                spoolingStartTime = millis();
            }
        }
        shouldStartMotorNow = false;
    }

    // ------------ Button handling with debounce ------------
    bool reading = digitalRead(BUTTON_PIN);
    if (reading != lastStableButtonState && now - lastDebounceTime > BUTTON_DEBOUNCE_MS) {
        lastDebounceTime = now;
        if (reading == LOW) {
            if (!isMotorRunning) {
                if (useFilamentSensor && !filamentDetected) {
                    feedbackActive = true;
                    feedbackTogglesRemaining = 10;
                    feedbackBlinkOn = false;
                    feedbackNextToggle = now;
                } else {
                    shouldStartMotorNow = true; delayStartUntil = now;
                }
            } else {
                isMotorRunning = false; progress = 0.0; totalEstimatedTime = 0;
                stepperStop();
                digitalWrite(EN_PIN, HIGH); digitalWrite(STEP_PIN, LOW);
                spoolingStartTime = 0; totalEstimatedTime = 0;
                sendStatus(true);
            }
        }
        lastStableButtonState = reading;
    }

    // ----------- Motor acceleration (speed ramp) --------------
    if (isMotorRunning && now - lastAccelUpdate > ACCEL_UPDATE_INTERVAL) {
        lastAccelUpdate = now;
        if (stepIntervalMicros > targetStepIntervalMicros) {
            stepIntervalMicros -= ACCEL_STEP;
            if (stepIntervalMicros < targetStepIntervalMicros) stepIntervalMicros = targetStepIntervalMicros;
        } else if (stepIntervalMicros < targetStepIntervalMicros) {
            stepIntervalMicros += ACCEL_STEP;
            if (stepIntervalMicros > targetStepIntervalMicros) stepIntervalMicros = targetStepIntervalMicros;
        }
        if (stepIntervalMicros != lastIntervalMicros) {
            stepperSetFreq(stepFreqFromIntervalUs(stepIntervalMicros));
            lastIntervalMicros = stepIntervalMicros;
        }
        if (stepIntervalMicros == targetStepIntervalMicros) {
            int currSpeedPercent = round((float)speedPercent * ((float)baseTargetStepIntervalMicros / (float)stepIntervalMicros));
            currSpeedPercent = constrain(currSpeedPercent, 50, 140);
            unsigned long newTotal = calibrationAt80Speed * (80.0 / currSpeedPercent);
            unsigned long elapsed = millis() - spoolingStartTime;
            if (totalEstimatedTime > 0) {
                float progressRatio = (float)elapsed / totalEstimatedTime;
                spoolingStartTime = millis() - (newTotal * progressRatio);
            }
            totalEstimatedTime = newTotal;
        }
    }

    // ----- End kickstart window -> return to stealthChop -----
    if (kickstartActive && now >= kickstartEnd) {
        driver.en_spreadCycle(false);
        kickstartActive = false;
    }

    // ------------- Connection/LED animation ------------------
    if (deviceConnected) {
        setLedDuty(LED_CONN_CHANNEL, 150);
    } else {
        if (now - lastConnLedTime >= 20) {
            lastConnLedTime = now;
            static int pulse = 0, dir = 4;
            pulse += dir;
            if (pulse >= 255) { pulse = 255; dir = -dir; }
            if (pulse <= 0)   { pulse = 0;   dir = -dir; }
            setLedDuty(LED_CONN_CHANNEL, (uint8_t)pulse);
        }
    }

    // -------------- Jingle trigger (on settings change) -------------
    if (triggerJingleNow != 0) {
        playStepperJingle();
        triggerJingleNow = 0;
    }
    
    // ----------- BLE: restart advertising if disconnected --------------
    if (!deviceConnected && !NimBLEDevice::getAdvertising()->isAdvertising()) {
        NimBLEDevice::startAdvertising();
    }

    // ----------- periodic Status-Update: every 200 ms -----------
    static unsigned long lastStatusTime = 0;
    if (millis() - lastStatusTime > 200) {
        sendStatus();
        lastStatusTime = millis();
    }
}
